{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\maali\\\\OneDrive\\\\Desktop\\\\MUSIC\\\\frontend\\\\src\\\\context\\\\SubscriptionContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { loadStripe } from '@stripe/stripe-js';\nimport { useAuth } from './AuthContext';\n\n// Create the context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SubscriptionContext = /*#__PURE__*/createContext();\n\n// Custom hook to use the subscription context\nexport const useSubscription = () => {\n  _s();\n  const context = useContext(SubscriptionContext);\n  if (!context) {\n    throw new Error('useSubscription must be used within a SubscriptionProvider');\n  }\n  return context;\n};\n\n// Provider component\n_s(useSubscription, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const SubscriptionProvider = ({\n  children\n}) => {\n  _s2();\n  const [hasSubscription, setHasSubscription] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const {\n    isAuthenticated\n  } = useAuth();\n  const [subscriptionDetails, setSubscriptionDetails] = useState(null);\n\n  // Check subscription status when auth state changes\n  useEffect(() => {\n    checkSubscriptionStatus();\n  }, [isAuthenticated]);\n  const checkSubscriptionStatus = async () => {\n    if (!isAuthenticated) {\n      setHasSubscription(false);\n      setLoading(false);\n      setSubscriptionDetails(null);\n      return;\n    }\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) {\n        setHasSubscription(false);\n        setLoading(false);\n        setSubscriptionDetails(null);\n        return;\n      }\n      const response = await axios.get('http://localhost:5000/api/subscription/status', {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n\n      // Check if user has access based on subscription status and period end\n      const hasAccess = response.data.hasSubscription;\n      const isCancelled = response.data.status === 'cancelled';\n      const currentPeriodEnd = new Date(response.data.currentPeriodEnd);\n      const now = new Date();\n\n      // User has access if either:\n      // 1. Subscription is active and not cancelled\n      // 2. Subscription is cancelled but still within the paid period\n      const shouldHaveAccess = hasAccess && (!isCancelled || isCancelled && currentPeriodEnd > now);\n      setHasSubscription(shouldHaveAccess);\n      setSubscriptionDetails({\n        ...response.data,\n        hasSubscription: shouldHaveAccess\n      });\n      setLoading(false);\n    } catch (err) {\n      console.error('Error checking subscription status:', err);\n      setError('Failed to check subscription status');\n      setLoading(false);\n      setHasSubscription(false);\n      setSubscriptionDetails(null);\n    }\n  };\n  const createCheckoutSession = async () => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) {\n        throw new Error('Not authenticated');\n      }\n      const response = await axios.post('http://localhost:5000/api/subscription/create-checkout-session', {}, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      const stripe = await loadStripe(process.env.REACT_APP_STRIPE_PUBLIC_KEY);\n      await stripe.redirectToCheckout({\n        sessionId: response.data.sessionId\n      });\n    } catch (err) {\n      console.error('Error creating checkout session:', err);\n      setError('Failed to create checkout session');\n      throw err;\n    }\n  };\n  const cancelSubscription = async () => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) {\n        throw new Error('Not authenticated');\n      }\n      const response = await axios.post('http://localhost:5000/api/subscription/cancel', {}, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n\n      // After successful cancellation, refetch the subscription status to get the latest state from the backend\n      await checkSubscriptionStatus();\n      return {\n        success: true,\n        message: response.data.message\n      };\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Error cancelling subscription:', error);\n      // Even on error, attempt to refetch status in case of partial success\n      checkSubscriptionStatus();\n      return {\n        success: false,\n        message: ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to cancel subscription'\n      };\n    }\n  };\n  const value = {\n    hasSubscription,\n    loading,\n    error,\n    createCheckoutSession,\n    checkSubscriptionStatus,\n    cancelSubscription,\n    subscriptionDetails // Ensure subscriptionDetails is included in the context value\n  };\n  return /*#__PURE__*/_jsxDEV(SubscriptionContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 146,\n    columnNumber: 5\n  }, this);\n};\n_s2(SubscriptionProvider, \"GR/owhIWzm+v+qEW8YWWQFmlpRQ=\", false, function () {\n  return [useAuth];\n});\n_c = SubscriptionProvider;\nexport default SubscriptionContext;\nvar _c;\n$RefreshReg$(_c, \"SubscriptionProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","axios","loadStripe","useAuth","jsxDEV","_jsxDEV","SubscriptionContext","useSubscription","_s","context","Error","SubscriptionProvider","children","_s2","hasSubscription","setHasSubscription","loading","setLoading","error","setError","isAuthenticated","subscriptionDetails","setSubscriptionDetails","checkSubscriptionStatus","token","localStorage","getItem","response","get","headers","Authorization","hasAccess","data","isCancelled","status","currentPeriodEnd","Date","now","shouldHaveAccess","err","console","createCheckoutSession","post","stripe","process","env","REACT_APP_STRIPE_PUBLIC_KEY","redirectToCheckout","sessionId","cancelSubscription","success","message","_error$response","_error$response$data","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/maali/OneDrive/Desktop/MUSIC/frontend/src/context/SubscriptionContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport axios from 'axios';\r\nimport { loadStripe } from '@stripe/stripe-js';\r\nimport { useAuth } from './AuthContext';\r\n\r\n// Create the context\r\nconst SubscriptionContext = createContext();\r\n\r\n// Custom hook to use the subscription context\r\nexport const useSubscription = () => {\r\n  const context = useContext(SubscriptionContext);\r\n  if (!context) {\r\n    throw new Error('useSubscription must be used within a SubscriptionProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Provider component\r\nexport const SubscriptionProvider = ({ children }) => {\r\n  const [hasSubscription, setHasSubscription] = useState(false);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const { isAuthenticated } = useAuth();\r\n  const [subscriptionDetails, setSubscriptionDetails] = useState(null);\r\n\r\n  // Check subscription status when auth state changes\r\n  useEffect(() => {\r\n    checkSubscriptionStatus();\r\n  }, [isAuthenticated]);\r\n\r\n  const checkSubscriptionStatus = async () => {\r\n    if (!isAuthenticated) {\r\n      setHasSubscription(false);\r\n      setLoading(false);\r\n      setSubscriptionDetails(null);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const token = localStorage.getItem('token');\r\n      if (!token) {\r\n        setHasSubscription(false);\r\n        setLoading(false);\r\n        setSubscriptionDetails(null);\r\n        return;\r\n      }\r\n\r\n      const response = await axios.get('http://localhost:5000/api/subscription/status', {\r\n        headers: { Authorization: `Bearer ${token}` }\r\n      });\r\n\r\n      // Check if user has access based on subscription status and period end\r\n      const hasAccess = response.data.hasSubscription;\r\n      const isCancelled = response.data.status === 'cancelled';\r\n      const currentPeriodEnd = new Date(response.data.currentPeriodEnd);\r\n      const now = new Date();\r\n      \r\n      // User has access if either:\r\n      // 1. Subscription is active and not cancelled\r\n      // 2. Subscription is cancelled but still within the paid period\r\n      const shouldHaveAccess = hasAccess && (!isCancelled || (isCancelled && currentPeriodEnd > now));\r\n      \r\n      setHasSubscription(shouldHaveAccess);\r\n      setSubscriptionDetails({\r\n        ...response.data,\r\n        hasSubscription: shouldHaveAccess\r\n      });\r\n      \r\n      setLoading(false);\r\n    } catch (err) {\r\n      console.error('Error checking subscription status:', err);\r\n      setError('Failed to check subscription status');\r\n      setLoading(false);\r\n      setHasSubscription(false);\r\n      setSubscriptionDetails(null);\r\n    }\r\n  };\r\n\r\n  const createCheckoutSession = async () => {\r\n    try {\r\n      const token = localStorage.getItem('token');\r\n      if (!token) {\r\n        throw new Error('Not authenticated');\r\n      }\r\n\r\n      const response = await axios.post(\r\n        'http://localhost:5000/api/subscription/create-checkout-session',\r\n        {},\r\n        {\r\n          headers: { Authorization: `Bearer ${token}` }\r\n        }\r\n      );\r\n\r\n      const stripe = await loadStripe(process.env.REACT_APP_STRIPE_PUBLIC_KEY);\r\n      await stripe.redirectToCheckout({\r\n        sessionId: response.data.sessionId\r\n      });\r\n    } catch (err) {\r\n      console.error('Error creating checkout session:', err);\r\n      setError('Failed to create checkout session');\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const cancelSubscription = async () => {\r\n    try {\r\n      const token = localStorage.getItem('token');\r\n      if (!token) {\r\n        throw new Error('Not authenticated');\r\n      }\r\n\r\n      const response = await axios.post(\r\n        'http://localhost:5000/api/subscription/cancel',\r\n        {},\r\n        {\r\n          headers: { Authorization: `Bearer ${token}` }\r\n        }\r\n      );\r\n\r\n      // After successful cancellation, refetch the subscription status to get the latest state from the backend\r\n      await checkSubscriptionStatus(); \r\n      \r\n      return { success: true, message: response.data.message };\r\n    } catch (error) {\r\n      console.error('Error cancelling subscription:', error);\r\n      // Even on error, attempt to refetch status in case of partial success\r\n      checkSubscriptionStatus();\r\n      return { \r\n        success: false, \r\n        message: error.response?.data?.message || 'Failed to cancel subscription'\r\n      };\r\n    }\r\n  };\r\n\r\n  const value = {\r\n    hasSubscription,\r\n    loading,\r\n    error,\r\n    createCheckoutSession,\r\n    checkSubscriptionStatus,\r\n    cancelSubscription,\r\n    subscriptionDetails // Ensure subscriptionDetails is included in the context value\r\n  };\r\n\r\n  return (\r\n    <SubscriptionContext.Provider value={value}>\r\n      {children}\r\n    </SubscriptionContext.Provider>\r\n  );\r\n};\r\n\r\nexport default SubscriptionContext; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}